1.  Also known as bounded buffer problem. You have a buffer you have a producer who adds events/items to the queue (like kafka queue)
    you have consumers who are taking things from the queue.
    We have shared resource - buffer
    we have multiple threads
    we will face race conditions/ data consistency issues

2.  Where can we actually run into data consistency issues?
    - Overflow
        -   we can have multiple producers and multiple consumers

        -   buffer size 5. Already filled 4
        -   P1 -> { 1. len = size(Q); 3. if (len < 5) add()}
        -   P2 -> { 2. len = size(Q); 4. if (len < 5) add()}
        -   If both P1 and P2 come at same time and try to add to queue

    - Underflow
        -   buffer size 5. Already filled 1
        -   Two consumers try to consume at the same time
        -   C1 -> {1. len = size(Q); 3. if(len >= 1) consume()}
        -   C2 -> {2. len = size(Q); 4. if(len >= 1) consume()}

3.  Solutions:
    1. Mutual Exclusion - via synchronized queue
        -   Only one producer will be able to add at time to buffer/queue
        -   Only one consumer will be able to consume at a time
        - Performance wise not optimal

    2.  If I have buffer size 5 and all are filled
        -   how many consumers can consume? -> 5
        -   how many producers will be able to produce? -> 0

    3. If I have buffer of size 5 and empty
        -   how many producers will be able to produce? -> 5
        -   how many consumers can consume? -> 0

    4. Multiple threads entering the critical section is Semaphore
        -   Generalization of a mutex
        -   Semaphore(n) -> n permits number -> how many threads can access critical section at a time
        -   mutex - is binary semaphore (semaphore(1))